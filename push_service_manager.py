#!/usr/bin/env python3
"""
Push Service Manager for Kismet remote data push services.
Creates and manages shell scripts which run the Kismet remote capture tools.
"""

import os
import sys
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict


class PushServiceManager:
    """Manages Kismet push services for WiFi and Bluetooth data."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        # App base dir: file lives in /opt/kismet-webui/push_service_manager.py
        self.base_dir = Path(__file__).resolve().parent
        # Directory to hold generated scripts and PID/log files
        self.service_dir = self.base_dir / "push_services"
        self.service_dir.mkdir(parents=True, exist_ok=True)

    # -----------------------------
    # Public: create service script
    # -----------------------------
    def create_push_service_script(self, service_data: Dict) -> Path:
        """
        Create (or overwrite) a .sh script which runs a remote capture.
        service_data keys expected:
          - name (str)
          - service_type ('WiFi' or 'Bluetooth')
          - adapter (str)         e.g. 'wlan0' or 'hci0'
          - sensor (str)          human-readable sensor name
          - kismet_ip (str)       hostname/IP of Kismet server
          - api_key (str)         Kismet API key
          - gps_api_key (str|None) optional; if set, WiFi adds metagps + spawns MetaGPSD
        """
        name = service_data["name"]
        s_type = service_data["service_type"]
        adapter = service_data["adapter"]
        sensor = service_data["sensor"]
        host = service_data["kismet_ip"]
        apikey = service_data.get("api_key", "") or ""
        gps_apikey = service_data.get("gps_api_key", "") or ""

        # Common prologue shared by both script types
        prologue = f"""#!/bin/bash
set -Eeuo pipefail

# Auto-generated by Kismet WebUI
# Service: {name}

REMOTE_HOST="{host}"
API_KEY="{apikey}"
ADAPTER="{adapter}"
SENSOR_NAME="{sensor}"
GPS_API_KEY="{gps_apikey}"

LOG_FILE="{self.service_dir / (name + '.log')}"

echo "==== $(date -Is) Starting service: {name} ====" | tee -a "$LOG_FILE"
echo "Remote host: $REMOTE_HOST" | tee -a "$LOG_FILE"
echo "Adapter: $ADAPTER" | tee -a "$LOG_FILE"
echo "Sensor name: $SENSOR_NAME" | tee -a "$LOG_FILE"

# Helper: wait for ping then port 2501
wait_for_kismet() {{
  local host="$1"
  local tries=60
  local n=1
  echo "Checking reachability for $host..." | tee -a "$LOG_FILE"
  while ! ping -c 1 -W 1 "$host" &>/dev/null; do
    [[ $n -ge $tries ]] && echo "ERROR: host $host not reachable" | tee -a "$LOG_FILE" && return 1
    echo "Waiting for host $host... ($n/$tries)" | tee -a "$LOG_FILE"
    sleep 2; n=$((n+1))
  done
  echo "Host reachable; waiting for TCP 2501..." | tee -a "$LOG_FILE"
  n=1
  while ! (echo > /dev/tcp/$host/2501) &>/dev/null; do
    [[ $n -ge $tries ]] && echo "ERROR: $host:2501 not open" | tee -a "$LOG_FILE" && return 1
    echo "Waiting for $host:2501... ($n/$tries)" | tee -a "$LOG_FILE"
    sleep 2; n=$((n+1))
  done
  echo "Kismet capture port is ready on $host:2501" | tee -a "$LOG_FILE"
}}

# Helper: wait for gpsd if GPS is enabled
wait_for_gpsd() {{
  local tries=60
  local n=1
  echo "GPS requested; waiting for gpsd on 127.0.0.1:2947" | tee -a "$LOG_FILE"
  while ! (echo > /dev/tcp/127.0.0.1/2947) &>/dev/null; do
    [[ $n -ge $tries ]] && echo "WARNING: gpsd not available, continuing without" | tee -a "$LOG_FILE" && return 0
    echo "Waiting for gpsd... ($n/$tries)" | tee -a "$LOG_FILE"
    sleep 2; n=$((n+1))
  done
  echo "gpsd is up" | tee -a "$LOG_FILE"
}}

# Ensure PATH has sbin dirs when running via systemd
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

# Readiness for Kismet
wait_for_kismet "$REMOTE_HOST"
"""

        if s_type == "WiFi":
            # WiFi script (with optional MetaGPSD)
            body = r"""
# Build kismet_cap_linux_wifi command
CMD="kismet_cap_linux_wifi --connect ${REMOTE_HOST}:2501"

if [[ -n "${GPS_API_KEY}" ]]; then
  # include metagps in data-source name
  CMD="${CMD} --source=${ADAPTER}:name=${SENSOR_NAME},metagps=${SENSOR_NAME}"
else
  CMD="${CMD} --source=${ADAPTER}:name=${SENSOR_NAME}"
fi

if [[ -n "${API_KEY}" ]]; then
  CMD="${CMD} --apikey=${API_KEY}"
fi

echo "Command: ${CMD}" | tee -a "$LOG_FILE"

while true; do
  # Start WiFi capture
  bash -c "${CMD}" >>"$LOG_FILE" 2>&1 &
  WIFI_PID=$!

  # Start MetaGPSD if requested
  if [[ -n "${GPS_API_KEY}" ]]; then
    wait_for_gpsd
    if [[ -x "/opt/metagps/venv/bin/python" && -f "/opt/metagps/metagpsd.py" ]]; then
      echo "Starting MetaGPSD..." | tee -a "$LOG_FILE"
      /opt/metagps/venv/bin/python /opt/metagps/metagpsd.py \
        --connect "${REMOTE_HOST}:2501" \
        --metagps "${SENSOR_NAME}" \
        --apikey  "${GPS_API_KEY}" >>"$LOG_FILE" 2>&1 &
      GPS_PID=$!
    else
      echo "MetaGPSD not installed; skipping GPS attachment" | tee -a "$LOG_FILE"
      GPS_PID=""
    fi
  else
    GPS_PID=""
  fi

  wait $WIFI_PID || true

  # stop gps sidecar if running
  if [[ -n "${GPS_API_KEY}" && -n "${GPS_PID}" ]]; then
    kill "${GPS_PID}" 2>/dev/null || true
  fi

  echo "WiFi capture exited, restarting in 5s..." | tee -a "$LOG_FILE"
  sleep 5
done
"""
        elif s_type == "Bluetooth":
            # Bluetooth script
            body = r"""
# Build kismet_cap_linux_bluetooth command
CMD="kismet_cap_linux_bluetooth --connect ${REMOTE_HOST}:2501 --source=${ADAPTER}:name=${SENSOR_NAME}"

if [[ -n "${API_KEY}" ]]; then
  CMD="${CMD} --apikey=${API_KEY}"
fi

echo "Command: ${CMD}" | tee -a "$LOG_FILE"

while true; do
  bash -c "${CMD}" >>"$LOG_FILE" 2>&1
  echo "Bluetooth capture exited, restarting in 5s..." | tee -a "$LOG_FILE"
  sleep 5
done
"""
        else:
            raise ValueError(f"Unknown service type: {s_type}")

        script_path = self.service_dir / f"{name}.sh"
        script_path.write_text(prologue + body)
        script_path.chmod(0o755)
        self.logger.info("Created push service script: %s", script_path)
        return script_path

    # -----------------------------
    # Public: start/stop/restart
    # -----------------------------
    def start_push_service(self, service_name: str) -> Dict[str, str]:
        """Start a push service in the background, recording its PID."""
        try:
            script_path = self.service_dir / f"{service_name}.sh"
            if not script_path.exists():
                return {"success": False, "message": f"Script not found: {script_path}"}

            pid_file = self.service_dir / f"{service_name}.pid"
            if pid_file.exists():
                try:
                    old = int(pid_file.read_text().strip())
                    os.kill(old, 0)  # raises if not running
                    return {"success": False, "message": f"{service_name} already running (PID {old})"}
                except (ProcessLookupError, ValueError, OSError):
                    pid_file.unlink(missing_ok=True)

            # Launch detached, redirect output at script level (the script handles logging)
            proc = subprocess.Popen(
                [str(script_path)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                start_new_session=True,
                cwd=str(self.base_dir),
                env=self._merged_env(),
            )
            pid_file.write_text(str(proc.pid))
            self.logger.info("Started %s (PID %d)", service_name, proc.pid)
            return {"success": True, "message": f"Started {service_name} (PID {proc.pid})"}
        except Exception as e:
            self.logger.error("Failed to start %s: %s", service_name, e)
            return {"success": False, "message": str(e)}

    def stop_push_service(self, service_name: str) -> Dict[str, str]:
        """Stop a push service via its recorded PID (kills the whole process group)."""
        try:
            pid_file = self.service_dir / f"{service_name}.pid"
            if not pid_file.exists():
                return {"success": False, "message": f"{service_name} is not running"}

            pid = int(pid_file.read_text().strip())
            try:
                os.killpg(os.getpgid(pid), 15)  # SIGTERM group
            except ProcessLookupError:
                pass
            pid_file.unlink(missing_ok=True)
            self.logger.info("Stopped %s (PID %d)", service_name, pid)
            return {"success": True, "message": f"Stopped {service_name}"}
        except Exception as e:
            self.logger.error("Failed to stop %s: %s", service_name, e)
            return {"success": False, "message": str(e)}

    def restart_push_service(self, service_name: str) -> Dict[str, str]:
        """Restart a push service."""
        self.stop_push_service(service_name)
        return self.start_push_service(service_name)

    # -----------------------------
    # Public: status/cleanup
    # -----------------------------
    def get_service_status(self, service_name: str) -> str:
        """Return 'running' | 'stopped' | 'unknown'."""
        try:
            pid_file = self.service_dir / f"{service_name}.pid"
            if not pid_file.exists():
                return "stopped"
            pid = int(pid_file.read_text().strip())
            try:
                os.kill(pid, 0)
                return "running"
            except ProcessLookupError:
                pid_file.unlink(missing_ok=True)
                return "stopped"
        except Exception:
            return "unknown"

    def cleanup_stale_services(self) -> None:
        """Remove PID files whose processes are gone."""
        for pidf in self.service_dir.glob("*.pid"):
            try:
                pid = int(pidf.read_text().strip())
                os.kill(pid, 0)
            except (ValueError, ProcessLookupError, OSError):
                pidf.unlink(missing_ok=True)
                self.logger.info("Removed stale PID file: %s", pidf.name)

    # -----------------------------
    # Helpers
    # -----------------------------
    def _merged_env(self) -> dict:
        """Ensure sbin paths are present when launched under systemd."""
        env = os.environ.copy()
        env["PATH"] = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:" + env.get("PATH", "")
        return env


# Singleton
push_service_manager = PushServiceManager()
